# 算法
## what why how
- 统计99%响应时间
    -  拙劣 每次排序,效率低   
    -  最佳 两个 堆, 高效

- 技术提升 
    - 多考虑非功能性需求   

- 从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法
    - 比如图书馆 书籍是数据结构，查找是算法
    - 数据结构是为算法服务的，算法要作用在特定的数据结构上，相辅相成
    - 例如数组支持随机访问，二分查找需要用数组来存储数据。而存储数据结构换成链表就无法支持二分查找，因为不支持链表不支持随机访问。
    - 数据结构是静态的，是组织数据的方式。如果不在其基础上构建，操作算法，孤立存在的数据结构是没有意义的。

- 掌握数据结构与算法的前提: 复杂度分析(时间，空间) 
    - 复杂度分析占有数据结构与算法的半壁江山，是其精髓 
    - 时间、空间复杂度
    - 更省、更快的存储、处理数据
    - 数据结构和算法解决的是如何更省、更快地存储和处理数据的问题。
    - 针对存储和处理数据的问题，需要资源消耗和效率的考量评估方法，这就是复杂度分析方法。
    - 如果你只掌握了数据结构和算法的特点和用法，但是没有学会复杂度分析，那就相当于只知道操作口诀,而没有掌握心法。
    - 只有把心法了然于胸，才能做到无招胜有招。
    - 复杂度分析会占有大篇幅，需要花大力气啃，必须要拿下,且要搞得非常熟练。否则后面的数据结构和算法很难学好。
    - 掌握好复杂度分析后，就是正题数据结构和算法了，有路线全图和常用路线图。
    ![alt](https://static001.geekbang.org/resource/image/91/a7/913e0ababe43a2d57267df5c5f0832a7.jpg)
- 常用数据结构和算法路线图
    - 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树；
    - 10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

- 如何学习
    - 要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景
    - 边学边练习，适度刷题
    ```
    除非你要面试 Google、Facebook 这样的公司，它们的算法题目非常非常难，必须大量刷题，才能在短期内提升应试正确率。如果是应对国内公司的技术面试，即便是 BAT 这样的公司，你只要彻底掌握这个专栏的内容，就足以应对。
    ```
    - 多问、多思考、多互动
    - 打怪升级学习法 解决坚持不下来的问题- 设定目标
    - 沉淀法 知识需要沉淀，不要想试图一下子掌握所有   
    `学习知识的过程是反复迭代、不断沉淀的过程。`
    - 立flag
    - 算法导论

## 复杂度分析
### 如何分析、统计算法的执行效率和资源消耗

**算法和数据结构是解决`快`和`省`的问题**  
**复杂度分析是算法学习的精髓。  **

### 统计方法
 - 事后统计法
    - 依赖测试环境
    - 与数据规模有关 
    `比如小规模数据，插入排序可能比快排还要快` 
  
  所以我们需要一个不用具体的测试数据来测,就可以粗略的估算算法的执行效率的方法。  
  另外一点是估算的都是最坏的情况。

### 大O表示法
  所有代码的执行时间(Tn)与每行代码的执行次数n成正比  
  T(n) = O(f(n))  
  n 数据规模  
  f(n) 每行代码执行次数的总和  
  O 表示代码的执行时间T(n)和f(n)b表达式成正比    
  大O时间复杂度表示法。  
  O表示代码执行时间随数据规模的增长的变化趋势,即渐进时间复杂度    
  公式中的低阶，常量，系数并不影响趋势的变化，所以只需要最最大量级，最高阶的表示即可。  

注意: 如果循环的次数是常量，那么复杂度为O(1)
  ### 时间复杂度分析技巧
  1. 只关注循环次数最多的一段代码
  2. 加法法则: 总复杂度等于量级最大的那段代码的复杂度
    ` 
    T = T1+T2 -> max(T1,T2)
   `
  3. 乘法原则
   T = T1*T2

### 常见时间复杂度分析
常见复杂度量级:  (按照数据量级递增)  

**多项式量级**:  
常量阶:  O(1)  
对数阶:  O(log(n))  
线性阶:  O(n)  
线性对数阶: O(nlog(n))  
平方阶: O(n^2)  
立方阶: O(n^3)  
k次方阶: O(n^k)  

**非多项式量级**  
指数阶: O(2^n)  
阶乘阶: O(n!)  

一种是O(1),O(log(n)),O(n^a)等，我们把它叫做多项式级的时间复杂度，因为它的规模n出现在底数的位置；另一种是O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。判定是否是多项式算法和非多项式算法就是看时间复杂度。

[能否用通俗的语言解释『多项式时间』？
](https://www.zhihu.com/question/24653072)  其中也包含关于 NP 时间复杂度的讨论

注意:  
1. 对数阶 等比数列   忽略底数
2. 两个不同规模m，n 加法原则O(m+n) 乘法原则与之前不变   
### 如何掌握好复杂度分析方法？
复杂度分析关键在于多练，所谓孰能生巧。
### 四种情况的时间复杂度

- 最好情况时间复杂度（best case time complexity） 
- 最坏情况时间复杂度（worst case time compexity）
- 平均情况时间复杂度（average case time compexity）
- 均摊时间复杂度（amortized time compexity）

优化过的代码在不同情况下时间复杂度是不一样的。  
同一段代码在不同情况下,时间复杂度有量级的差距，所以使用最好，最坏，平均时间复杂度来分析。  

大部分情况下，我们并不区分上述三种复杂度。    

- 均摊时间复杂度

分析各种情况的时间复杂度，对于我们优化代码有很大帮助。尤其是考虑各种分支情况。   






https://exercism.io/ 
leetcode 















































### 




# resource
- 王争: 数据结构与算法之美
- 覃超 
- leetcode 
- 极客时间 数据结构
- 《图解数据结构》
- 《图解算法》
- 《java数据结构》
- python实现